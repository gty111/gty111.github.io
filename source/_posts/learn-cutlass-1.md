---
title: learn-cutlass-1
date: 2023-03-21 09:00:19
categories:
- Technology
tags:
- cutlass
toc: true
---

In cutlass 3.0, it introduces a new library, Cute, to describe and manipulate tensors of threads and data. I think the core of cutlass is GEMM(or other computations) and data movement.

<!-- more -->

## Different types of GEMM

| TYPE of GEMM | BITS of DATA | TYPE of DATA |
| - | -| - |
| HGEMM | 16 | floating-point number |
| SGEMM | 32 | floating-point number |
| DGEMM | 64 | floating-point number |
| IGEMM | 8 or 16 or 32 or 64 | integer |

## RowMajorInterleaved (ColumnMajorInterleaved)

```c++
#include "cutlass/layout/matrix.h"
template<int Interleave> struct cutlass::layout::RowMajorInterleaved<Interleave>;
```

RowMajorInterleaved is a layout which confused me. I didn't know the meaning of Interleaved.So I create an example to figure it out.

```c++

#include <iostream>
#include <cstdio>

// Defines cutlass::layout::RowMajorInterleave
#include "cutlass/layout/matrix.h"

// Defines cutlass::HostTensor<>
#include "cutlass/util/host_tensor.h"

// Defines cutlass::MatrixCoord
#include "cutlass/matrix_coord.h"

#define M 4
#define N 4

int main(){
    cutlass::HostTensor<int,cutlass::layout::RowMajorInterleaved<2> > A(cutlass::MatrixCoord(M,N));
    
    int num = 0;
    for(int i=0;i<M;i++)
    for(int j=0;j<N;j++){
        A.at({i,j}) = ++num; 
    }

    int *A_ = A.host_data();
    for(int i=0;i<A.capacity();i++){
        printf("%3d ",A_[i]);
        // if((i+1)%N==0)printf("\n");
    }
    /**
     *  output:
     *  1 5 2 6 3 7 4 8 9 13 10 14 11 15 12 16
     *  
    */
}
```

If tensor A is a simple RowMajor, the output should be this

```
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
```
In my opinion, `Interleaved` means it will iterate in shape(1) with size `Interleave` and then iterate in shape(0). 
Other things need to mind is `Interleaved` may cause padding of a matrix, like

```c++
#define M 3
#define N 3
cutlass::HostTensor<int,cutlass::layout::RowMajorInterleaved<2> > A(cutlass::MatrixCoord(M,N));
int num = 0;
for(int i=0;i<M;i++)
for(int j=0;j<N;j++){
    A.at({i,j}) = ++num; 
}
/**
 * the element in A should be 
 * 1 4 2 5 3 6 7 0 8 0 9 0
```

## typename in C++ 
In cutlass, you will see `typename` everywhere. Obviously, you can use `typename` when building template. But it has other usage, such as 
> The following is generated by chatgpt
```c++
template<typename T>
void foo() {
    typename T::iterator it;
    // ...
}
``` 
In C++, the typename keyword is used to specify that a dependent name is a type. A dependent name is a name that depends on a template parameter, and the compiler cannot determine whether the name refers to a type or some other entity until the template is instantiated with concrete types.

Consider the above example.

Here, T::iterator is a dependent name because it depends on the template parameter T. Without the typename keyword, the compiler would not be able to determine whether T::iterator is a type or a member variable until T is instantiated with a concrete type. The typename keyword tells the compiler that T::iterator is a type.

Note that typename is only needed when using a dependent name as a type. If the name does not depend on a template parameter, or if it is not used as a type, the typename keyword should not be used.

## ThreadblockSwizzle
> The following is generated by chatgpt
In Cutlass, ThreadblockSwizzle is a feature that allows for different threadblock configurations to be used when performing matrix-multiplication operations. ThreadblockSwizzle can be used to optimize the performance of GEMM (General Matrix Multiply) operations on GPUs, by mapping the threadblocks to the data in a way that maximizes data reuse and minimizes thread divergence.

ThreadblockSwizzle functions in Cutlass can be used to map the blockIdx (block index) of the CUDA grid to GEMM problems. These functions implement different strategies for organizing the threads within a threadblock, such as tiling, padding, and transposing, in order to improve the efficiency of memory access patterns and to maximize the utilization of GPU resources.

Overall, ThreadblockSwizzle in Cutlass is a powerful feature that can significantly improve the performance of matrix-multiplication operations on GPUs, particularly for large-scale problems.

## Comparison between typedef and using 
> The following is generated by chatgpt
In C++, both typedef and using can be used to create aliases for types. Here are some key differences between the two:

### Syntax

```c++
typedef <existing_type> <new_type_alias>;
using <new_type_alias> = <existing_type>;
```

### Scope

typedef: A type alias created using typedef has the same scope as the original type. This means that it is accessible anywhere that the original type is accessible.

using: A type alias created using using has a narrower scope than the original type. It is only accessible within the block in which it is defined.

### Functionality
typedef: typedef can only be used to create aliases for types. It cannot be used to create template aliases.

using: using can be used to create both type aliases and template aliases. This makes it more versatile than typedef.

### Readability

typedef: typedef can only be used to create aliases for types. It cannot be used to create template aliases.

using: using can be used to create both type aliases and template aliases. This makes it more versatile than typedef.

## 05_batched_gemm

Batched gemm can be illustrated as follows
![](/img/batched_gemm.jpg)

