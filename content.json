{"posts":[{"title":"Tips for Linux","text":"This passage is to log some tips about Linux. How to change default shell : chsh kown_hosts log the public key of the host you have visited How to use ssh /etc/passwd ls","link":"/2023/03/30/Tips-for-Linux/"},{"title":"我的一生一芯","text":"一生一芯是一个开放社区性质的公益教学项目，主要是为了解决中国芯片设计人才缺失的问题，主办方是国科大和计算所，要求学生设计出一块自己的CPU并成功流片。 以下是我的一生一芯项目的记录 github 腾讯文档 初识一生一芯记得还是在大四阶段接触到的一生一芯计划，当时是在西电保研群某个大佬发的链接，于是就报名参加了。大四应该是整个大学最轻松的时候（指心情方面），保研阶段结束，于是就开始刷各种实验或写毕设。 深入一生一芯前期最终要的就是要完成两个实验，数字电路基础实验(dlco)和计算机系统基础实验(PA)。 数字电路基础实验dlco主要是通过nvboard(一个虚拟FPGA开发板)进行实验，而实验语言便是verilog。我之前从来没有接触过硬件相关知识，所以会习惯用软件编程的思想写硬件程序(verilog)，这也是我最终退出一生一芯的主要原因。在完成dlco实验过程中，其中最令我印象深刻的是字符输入界面，我在上面投入了很多时间，最终也实现了几乎所有的扩展要求，当打开界面，在键盘上敲下各个按键时字母符号出现在屏幕上时，感觉十分有成就感。 计算机系统基础实验PA实验是继CSAPP LAB后第二个令我震惊的实验，感觉我本科实验真的好lj。简单地介绍下PA是什么，它要求学生实现一个经过简化但功能完备的x86/mips32/riscv32(64)模拟器，最终可以运行galgame等游戏。PA可以说是由浅入深，让学生从零基础逐渐深入到计算机底层的各个领域。PA实验给我带来最大的帮助就是了解了riscv指令集和模拟器究竟是什么。 CPU编写一生一芯顾名思义肯定是要写CPU啦，许多人一听到写CPU就会感觉“哇，这也太难了吧”，其实你可以把它想得很简单，如果用软件编程的思想来看是一个流程：写程序（verilog或chisel）=&gt; 逻辑综合(可以理解为软件的编译) =&gt; 剩下全部丢给后端去做了。所以芯片设计对于我的理解就是写verilog，我想“C++我都不怕，怎么可能怕verilog呢?”，于是开始了漫长的verilog编写，我甚至迭代了十几个版本（每个版本都通过了benchmark测试正确性），最后发现自己写的verilog还是lj。这时候，我才发现我缺少了最重要的一环，硬件设计思想，于是我默默地退出了。 后记尽管我的一生一芯计划并没有走到最后，但是我在参加的过程中还是收货了很多知识，这对我之后的学习起了很大的帮助。我对于一生一芯计划评价还是很高的，它可以系统地训练或培养学生进行芯片设计，从中你可以学习到很多体系结构的知识，希望一生一芯可以一直走下去吧，也希望中国的芯片巨头早日出现(对标苹果,intel,Nvidia,AMD)。","link":"/2023/03/23/YSYX/"},{"title":"How to build this web","text":"This web is building by Hexo and Icarus. Install Node.js for linux reference this for windows through nvs or nvm for mac through Homebrew or MacPorts Install Hexo (require Node.js)1npm install -g hexo-cli Create your site123456hexo init &lt;folder&gt; cd &lt;folder&gt;npm installnpm install -S hexo-theme-icarus hexo-renderer-inferno # install icarushexo config theme icarus # use theme icarushexo server # start server at localhost Tips about Hexo or Icarus Add read more to your blogs : just add &lt;!-- more --&gt; in your md at proper position. To search icons to use, visit here Reference hexo-tutorial getting-started-with-icarus","link":"/2023/03/20/build_web/"},{"title":"github初级使用指南","text":"什么是github generated by chatgpt GitHub是一个基于互联网的Git代码托管平台，它为开发者提供了一个在线上协作开发、版本控制和代码分享的平台。开发者可以将自己的代码托管在GitHub上，与他人协作开发项目，创建开源软件，分享自己的代码以及与其他开发者互相交流和学习。GitHub上的开源项目数量很多，涉及各种编程语言和开发领域，它已经成为了全球最大的开源社区之一。除此之外，GitHub也提供了一些其他的功能，例如问题跟踪、维基、团队协作等。 如何使用github我对github的理解就是学习开源项目、参与开源项目或托管(分享)自己代码。 基础知识 Star: 在github上star一个仓库可以理解为收藏，可以在你的stars中看到你收藏的所有仓库 Fork: 在github上fork一个仓库可以理解为将这个仓库拷贝一份到自己名下（因为仓库的所有权是在别人，如果想要修改该仓库需要Fork到自己的名下或者提pull resquests即PR） Follow: 在github上follow一个人可以理解为关注，并且你可以收到TA之后的动态推送(比如TA创建仓库、star仓库等)，推送可以在这里的following看到 README: github一般每个仓库会有一个文件叫README.md，它的意义是github仓库的说明书，默认情况下你打开一个github仓库会展示给你，你可以通过阅读README来了解一个仓库 ssh key: github的身份验证机制，它允许你通过ssh协议访问github仓库(命令行方式)，而不需要用户名和密码 private or public: github仓库主要分为private和public，别人看不到你的private仓库，只能看到你的public仓库 github常年处于半墙状态，所以使用可能有些不方便 托管代码当你创建了一个仓库后，你可以在网页上编辑或者在本地编辑好后上传至github。一般来说，我们会选择在本地编辑之后上传的方式，这种方式首先需要我们配置后github的ssh key，关于如何配置ssh key网上应该有很多教程了。 当你在github上新建仓库后，github会在新仓库给出命令提示，你可以按照github命令提示进行操作。 学习开源项目github上有很多好玩且优秀的开源项目，你可以通过搜索发现自己感兴趣的开源项目(吐槽下github的搜索功能感觉很一般)，或者通过follow领域的大牛来看TA们star的项目或创建维护的项目。","link":"/2023/03/29/github-use-guide/"},{"title":"learn-cutlass-0","text":"learn cutlass is a series of tutorials to learn cutlass by reading its examples or source code CUTLASS is a header-only template library. After reading that, you will be lost in templates. 00_basic_gemm12345678910111213141516171819// Defines cutlass::gemm::device::Gemm, the generic Gemm computation template class.#include &quot;cutlass/gemm/device/gemm.h&quot;using CutlassGemm = cutlass::gemm::device::Gemm&lt;A_TYPE,A_LAYOUT,B_TYPE,B_LAYOUT,C_TYPE,C_LAYOUT&gt; ;// where A_TYPE is Data-type of A matrix and A_LAYOUT is Layout of A matrixCutlassGemm gemm_operator;CutlassGemm::Arguments args({M , N, K}, {A_POINTER, lda}, {B_POINTER, ldb}, {C_POINTER, ldc}, {C_POINTER, ldc}, {alpha, beta});// where A_POINTER is pointer of A matrix and lda is the number of elements between consecutive rows or colmnscutlass::Status status = gemm_operator(args);// call gemm operation 01_cutlass_utilities1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// CUTLASS includes needed for half-precision GEMM kernel#include &quot;cutlass/cutlass.h&quot;#include &quot;cutlass/core_io.h&quot;#include &quot;cutlass/layout/matrix.h&quot;#include &quot;cutlass/gemm/device/gemm.h&quot;//// CUTLASS utility includes//// Defines operator&lt;&lt;() to write TensorView objects to std::ostream#include &quot;cutlass/util/tensor_view_io.h&quot;// Defines cutlass::HostTensor&lt;&gt;#include &quot;cutlass/util/host_tensor.h&quot;// Defines cutlass::half_t#include &quot;cutlass/numeric_types.h&quot;// Defines device_memory::copy_device_to_device()#include &quot;cutlass/util/device_memory.h&quot;// Defines cutlass::reference::device::TensorFillRandomGaussian()#include &quot;cutlass/util/reference/device/tensor_fill.h&quot;// Defines cutlass::reference::host::TensorEquals()#include &quot;cutlass/util/reference/host/tensor_compare.h&quot;// Defines cutlass::reference::host::Gemm()#include &quot;cutlass/util/reference/host/gemm.h&quot;// another way to call gemm without using Argumentscutlass::Status status = gemm_op({ {M, N, K}, {A, lda}, {B, ldb}, {C, ldc}, {C, ldc}, {alpha, beta} });// define a tensor (M,N) in cutlass, where DTYPE is data typecutlass::HostTensor&lt;DTYPE,LAYOUT&gt; VAR(cutlass::MatrixCoord(M,N)) ;cutlass::HostTensor&lt;cutlass::half_t, cutlass::layout::ColumnMajor&gt; A(cutlass::MatrixCoord(M, K));// fill a tensor (RandomGaussian) where A.device_view() return TensorView of that tensor in cutlasscutlass::reference::device::TensorFillRandomGaussian( A.device_view(), seed, mean, stddev, bits_less_than_one );// copy data from device to device in cutlass where A.device_data() return pointer of that tensor// A.capacity() return the logical capacity based on extent and layout. May differ from size().cutlass::device_memory::copy_device_to_device( C_reference.device_data(), C_cutlass.device_data(), C_cutlass.capacity());// Copies data from device to hostA.sync_host();// Copies data from host to deviceA.sync_device();// Compute the reference result using the host-side GEMM reference implementation.// I think the only difference between TensorView and TensorRef is that TensorView is read-only // while TensorRef can return pointer of matrixcutlass::reference::host::Gemm&lt; cutlass::half_t, // ElementA cutlass::layout::ColumnMajor, // LayoutA cutlass::half_t, // ElementB cutlass::layout::ColumnMajor, // LayoutB cutlass::half_t, // ElementOutput cutlass::layout::ColumnMajor, // LayoutOutput cutlass::half_t, // ScalarType cutlass::half_t // ComputeType&gt; gemm_ref;gemm_ref( {M, N, K}, // problem size (type: cutlass::gemm::GemmCoord) alpha, // alpha (type: cutlass::half_t) A.host_ref(), // A (type: TensorRef&lt;half_t, ColumnMajor&gt;) B.host_ref(), // B (type: TensorRef&lt;half_t, ColumnMajor&gt;) beta, // beta (type: cutlass::half_t) C_reference.host_ref() // C (type: TensorRef&lt;half_t, ColumnMajor&gt;));// Compare reference to computed resultscutlass::reference::host::TensorEquals( C_reference.host_view(), C_cutlass.host_view()); 04_tile_iterator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// CUTLASS includes#include &quot;cutlass/transform/threadblock/predicated_tile_iterator.h&quot;#include &quot;cutlass/layout/pitch_linear.h&quot;#include &quot;cutlass/transform/pitch_linear_thread_map.h&quot;//// CUTLASS utility includes//// Defines operator&lt;&lt;() to write TensorView objects to std::ostream#include &quot;cutlass/util/tensor_view_io.h&quot;// Defines cutlass::HostTensor&lt;&gt;#include &quot;cutlass/util/host_tensor.h&quot;// Defines cutlass::reference::host::TensorFill() and// cutlass::reference::host::TensorFillBlockSequential()#include &quot;cutlass/util/reference/host/tensor_fill.h&quot;// For this example, we chose a &lt;64, 4&gt; tile shape. The PredicateTileIterator expects// PitchLinearShape and PitchLinear layout.using Shape = cutlass::layout::PitchLinearShape&lt;64, 4&gt;;using Layout = cutlass::layout::PitchLinear;using Element = int;int const kThreads = 32;// ThreadMaps define how threads are mapped to a given tile. The PitchLinearStripminedThreadMap// stripmines a pitch-linear tile among a given number of threads, first along the contiguous// dimension then along the strided dimension.using ThreadMap = cutlass::transform::PitchLinearStripminedThreadMap&lt;Shape, kThreads&gt;;// Define the PredicateTileIterator, using TileShape, Element, Layout, and ThreadMap typesusing Iterator = cutlass::transform::threadblock::PredicatedTileIterator&lt; Shape, Element, Layout, 1, ThreadMap&gt;;cutlass::Coord&lt;2&gt; copy_extent = cutlass::make_Coord(M, K);cutlass::Coord&lt;2&gt; alloc_extent = cutlass::make_Coord(M, K);// another way to define tensor// Allocate source and destination tensorscutlass::HostTensor&lt;Element, Layout&gt; src_tensor(alloc_extent);cutlass::HostTensor&lt;Element, Layout&gt; dst_tensor(alloc_extent);Element oob_value = Element(-1);// Initialize destination tensor with all -1scutlass::reference::host::TensorFill(dst_tensor.host_view(), oob_value);// Initialize source tensor with sequentially increasing valuescutlass::reference::host::BlockFillSequential(src_tensor.host_data(), src_tensor.capacity());dst_tensor.sync_device();src_tensor.sync_device();typename Iterator::Params dst_params(dst_tensor.layout());typename Iterator::Params src_params(src_tensor.layout());dim3 block(kThreads, 1);dim3 grid(1, 1);// Launch copy kernel to perform the copycopy&lt;Iterator&gt;&lt;&lt;&lt; grid, block &gt;&gt;&gt;( dst_params, dst_tensor.device_data(), src_params, src_tensor.device_data(), copy_extent);// copy functiontemplate &lt;typename Iterator&gt;__global__ void copy( typename Iterator::Params dst_params, typename Iterator::Element *dst_pointer, typename Iterator::Params src_params, typename Iterator::Element *src_pointer, cutlass::Coord&lt;2&gt; extent) { Iterator dst_iterator(dst_params, dst_pointer, extent, threadIdx.x); Iterator src_iterator(src_params, src_pointer, extent, threadIdx.x); // PredicatedTileIterator uses PitchLinear layout and therefore takes in a PitchLinearShape. // The contiguous dimension can be accessed via Iterator::Shape::kContiguous and the strided // dimension can be accessed via Iterator::Shape::kStrided int iterations = (extent[1] + Iterator::Shape::kStrided - 1) / Iterator::Shape::kStrided; typename Iterator::Fragment fragment; for(; iterations &gt; 0; --iterations) { src_iterator.load(fragment); dst_iterator.store(fragment); ++src_iterator; ++dst_iterator; }}","link":"/2023/03/20/learn-cutlass-0/"},{"title":"learn-cutlass-1","text":"In cutlass 3.0, it introduces a new library, Cute, to describe and manipulate tensors of threads and data. I think the core of cutlass is GEMM(or other computations) and data movement. Different types of GEMM TYPE of GEMM BITS of DATA TYPE of DATA HGEMM 16 floating-point number SGEMM 32 floating-point number DGEMM 64 floating-point number IGEMM 8 or 16 or 32 or 64 integer RowMajorInterleaved (ColumnMajorInterleaved)12#include &quot;cutlass/layout/matrix.h&quot;template&lt;int Interleave&gt; struct cutlass::layout::RowMajorInterleaved&lt;Interleave&gt;; RowMajorInterleaved is a layout which confused me. I didn’t know the meaning of Interleaved.So I create an example to figure it out. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;// Defines cutlass::layout::RowMajorInterleave#include &quot;cutlass/layout/matrix.h&quot;// Defines cutlass::HostTensor&lt;&gt;#include &quot;cutlass/util/host_tensor.h&quot;// Defines cutlass::MatrixCoord#include &quot;cutlass/matrix_coord.h&quot;#define M 4#define N 4int main(){ cutlass::HostTensor&lt;int,cutlass::layout::RowMajorInterleaved&lt;2&gt; &gt; A(cutlass::MatrixCoord(M,N)); int num = 0; for(int i=0;i&lt;M;i++) for(int j=0;j&lt;N;j++){ A.at({i,j}) = ++num; } int *A_ = A.host_data(); for(int i=0;i&lt;A.capacity();i++){ printf(&quot;%3d &quot;,A_[i]); // if((i+1)%N==0)printf(&quot;\\n&quot;); } /** * output: * 1 5 2 6 3 7 4 8 9 13 10 14 11 15 12 16 * */} If tensor A is a simple RowMajor, the output should be this 11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In my opinion, Interleaved means it will iterate in shape(1) with size Interleave and then iterate in shape(0).Other things need to mind is Interleaved may cause padding of a matrix, like 1234567891011#define M 3#define N 3cutlass::HostTensor&lt;int,cutlass::layout::RowMajorInterleaved&lt;2&gt; &gt; A(cutlass::MatrixCoord(M,N));int num = 0;for(int i=0;i&lt;M;i++)for(int j=0;j&lt;N;j++){ A.at({i,j}) = ++num; }/** * the element in A should be * 1 4 2 5 3 6 7 0 8 0 9 0 typename in C++In cutlass, you will see typename everywhere. Obviously, you can use typename when building template. But it has other usage, such as The following is generated by chatgpt 12345template&lt;typename T&gt;void foo() { typename T::iterator it; // ...} In C++, the typename keyword is used to specify that a dependent name is a type. A dependent name is a name that depends on a template parameter, and the compiler cannot determine whether the name refers to a type or some other entity until the template is instantiated with concrete types. Consider the above example. Here, T::iterator is a dependent name because it depends on the template parameter T. Without the typename keyword, the compiler would not be able to determine whether T::iterator is a type or a member variable until T is instantiated with a concrete type. The typename keyword tells the compiler that T::iterator is a type. Note that typename is only needed when using a dependent name as a type. If the name does not depend on a template parameter, or if it is not used as a type, the typename keyword should not be used. ThreadblockSwizzle The following is generated by chatgpt In Cutlass, ThreadblockSwizzle is a feature that allows for different threadblock configurations to be used when performing matrix-multiplication operations. ThreadblockSwizzle can be used to optimize the performance of GEMM (General Matrix Multiply) operations on GPUs, by mapping the threadblocks to the data in a way that maximizes data reuse and minimizes thread divergence. ThreadblockSwizzle functions in Cutlass can be used to map the blockIdx (block index) of the CUDA grid to GEMM problems. These functions implement different strategies for organizing the threads within a threadblock, such as tiling, padding, and transposing, in order to improve the efficiency of memory access patterns and to maximize the utilization of GPU resources. Overall, ThreadblockSwizzle in Cutlass is a powerful feature that can significantly improve the performance of matrix-multiplication operations on GPUs, particularly for large-scale problems. Comparison between typedef and using The following is generated by chatgpt In C++, both typedef and using can be used to create aliases for types. Here are some key differences between the two: Syntax12typedef &lt;existing_type&gt; &lt;new_type_alias&gt;;using &lt;new_type_alias&gt; = &lt;existing_type&gt;; Scopetypedef: A type alias created using typedef has the same scope as the original type. This means that it is accessible anywhere that the original type is accessible. using: A type alias created using using has a narrower scope than the original type. It is only accessible within the block in which it is defined. Functionalitytypedef: typedef can only be used to create aliases for types. It cannot be used to create template aliases. using: using can be used to create both type aliases and template aliases. This makes it more versatile than typedef. Readabilitytypedef: typedef can only be used to create aliases for types. It cannot be used to create template aliases. using: using can be used to create both type aliases and template aliases. This makes it more versatile than typedef. 05_batched_gemmThis example demonstrates how to use cutlass to compute a batched strided gemm in two different ways: By specifying pointers to the first matrices of the batch and the stride between the consecutive matrices of the batch (this is called a strided batched gemm). By copying pointers to all matrices of the batch to the device memory (this is called an array gemm). In the example, it simply calls two APIs which is cutlass::gemm::device::GemmArray and cutlass::gemm::device::GemmBatched. So I think it is time to read the source of cutlass. GemmArrayLet’s take GemmArray as an example. 1234567891011121314151617181920212223242526272829// GemmArray is defined in following file#include &quot;cutlass/gemm/device/gemm_array.h&quot;// simplified defination of GemmArraytemlate&lt; typename ElementA_, typename LayoutA_, typename ElementB_, typename LayoutB_, typename ElementC_, typename LayoutC_ //...&gt;class GemmArray{ public: // ignore some detailed attribute and functions using GemmKernel = kernel::GemmArray&lt;typename DefaultGemmKernel::Mma, typename DefaultGemmKernel::Epilogue, ThreadblockSwizzle&gt;; Status run(cudaStream_t stream = nullptr) { // ignore some detailed codes cutlass::Kernel&lt;GemmKernel&gt;&lt;&lt;&lt;grid, block, smem_size, stream&gt;&gt;&gt;(params_); } // overload operator () for calling gemm_op(...) Status operator()(cudaStream_t stream = nullptr) { return run(stream); }}; See, it is not very complicated. The class GemmArray is just built with many templates(the context of a class) and overloads operator () to call cutlass::Kernel. Then the question is coming. What is cutlass:Kernal? 1234567891011121314151617#include &quot;cutlass/device_kernel.h&quot;/// Generic CUTLASS kernel template.template &lt;typename Operator&gt;__global__void Kernel(typename Operator::Params params) { // Dynamic shared memory base pointer extern __shared__ int SharedStorageBase[]; // Declare pointer to dynamic shared memory. typename Operator::SharedStorage *shared_storage = reinterpret_cast&lt;typename Operator::SharedStorage *&gt;(SharedStorageBase); Operator op; op(params, *shared_storage);}; It is just a kernel template. So the important is Opearator of cutlass::Kernal which stands for cutlass::gemm::kernel::GemmArray. 123456789101112131415#include &quot;cutlass/gemm/kernel/gemm_array.h&quot;template &lt; typename Mma_, ///! Threadblock-scoped matrix multiply-accumulate typename Epilogue_, ///! Epilogue typename ThreadblockSwizzle_ ///! Threadblock swizzling function&gt;struct GemmArray{ // ignore some detailed attribute and functions CUTLASS_DEVICE void operator()(Params const &amp;params, SharedStorage &amp;shared_storage) { // codes run on device }}; So operator() is the core of class/struct in cutlass. And all the others are the context of that class/struct.","link":"/2023/03/21/learn-cutlass-1/"},{"title":"learn-cutlass-2","text":"I always wonder why cutlass provides many kinds of implementions of GEMM instead of just only one. In my opinion, in different situations the best implementions of GEMM differs. So that is what differs cutlass from cublas. You can make your own custiomlized implemention of GEMM to provide the best performance. The annotation in cutlass: When the template variables are passed to instantiate CUTLASS GEMM kernel, it internally deduce the amount of threads needed per thread-block, amount of shared memory, storing data in bank-conflict free manner, and ton of other variables required to compose, initialize and launch a high performance GEMM kernel. This is the beauty of CUTLASS, it relieves developer from understanding and coding complicated hardware optimizations which can easily go wrong. CUTLASS divides a kernel into hierarchical composable sections. Which means, at each thread, warp and thread-block level, they compute on their own tile-size with higher level of tile sizes being composed from lower level ones. Multiple thread-tiles (tile size each thread computes) can be used to form warp-tiles (tile size each warp computes) and multiple warp tiles can be used to compute threadblock-tile (tile size computed by a threadblock). InstructionShapeWhen it is used in tensor core operations for specifying the basic GEMM (M,N,K) such as 1using InstructionShape = cutlass::gemm::GemmShape&lt;8, 8, 4&gt;; // TensorCore instruction shape Or it is used in SIMT operations 1234// SIMT (except dp4a)using InstructionShape = cutlass::gemm::GemmShape&lt;1, 1, 1&gt;;// SIMT dp4ausing InstructionShape = cutlass::gemm::GemmShape&lt;1, 1, 4&gt;; dp4a12dp4a.atype.btype d, a, b, c;.atype = .btype = { .u32, .s32 }; Four-way byte dot product which is accumulated in 32-bit result.Operand a and b are 32-bit inputs which hold 4 byte inputs in packed form for dot product.Operand c has type .u32 if both .atype and .btype are .u32 else operand c has type .s32. 12345678d = c;∕∕ Extract 4 bytes from a 32bit input and sign or zero extend∕∕ based on input type.Va = extractAndSignOrZeroExt_4(a, .atype);Vb = extractAndSignOrZeroExt_4(b, .btype);for (i = 0; i &lt; 4; ++i) {d += Va[i] * Vb[i];} EpilogueThe above code focuses only on the matrix multiply computation C = AB whose result is held in the registers of each thread within the threadblock. The mapping of logical elements in the output tile to each thread is chosen to maximize performance of the matrix multiply computation but does not result in efficient, coalesced loads and stores to global memory. The epilogue is a separate phase in which threads exchange data through shared memory then cooperatively access global memory using efficient striped access patterns. It is also the phase in which linear scaling and other elementwise operations may be conveniently computed using the matrix product results as inputs. CUTLASS defines several typical epilogue operations such as linear scaling and clamping, but other device-side function call operators may be used to perform custom operations. 06_splitK_gemmsplitK is partitioning a GEMM with its K dimension. \\(C = \\sum_{i=1}^{K}{A_i}*B_i\\) 12// Define cutlass::gemm::device::GemmSplitKParallel#include &quot;cutlass/gemm/device/gemm_splitk_parallel.h&quot; In cutlass, templates are arguments/context of a function. Not all the combinations of templates work. So you need to know which combination is correct. To know its more, try to build a splitK using arch sm80 instead of sm70. One possible solution is as follows: 1234567891011121314142c142&lt; using SmArch = cutlass::arch::Sm70;---&gt; using SmArch = cutlass::arch::Sm80;150c150&lt; using ShapeMMAOp = cutlass::gemm::GemmShape&lt;8, 8, 4&gt;; // &lt;- MMA Op tile M = 8, N = 8, K = 4---&gt; using ShapeMMAOp = cutlass::gemm::GemmShape&lt;16, 8, 16&gt;; // &lt;- MMA Op tile M = 16, N = 8, K = 16188,189c188,189&lt; if (props.major != 7) {&lt; std::cerr &lt;&lt; &quot;Volta Tensor Ops must be run on a machine with compute capability of 70, 72, or 75.&quot;---&gt; if (props.major != 8 &amp;&amp; props.minor != 0) {&gt; std::cerr &lt;&lt; &quot;Amphere Tensor Ops must be run on a machine with compute capability of 80.&quot;","link":"/2023/03/24/learn-cutlass-2/"},{"title":"learn-cutlass-3","text":"Warp-level GEMMs may be implemented either by TensorCores issuing mma.sync or wmma instructions, or by thread-level matrix computations issued to CUDA cores. Wmma is an API in CUDA C++ for using TensorCores and if you want to use TensorCores by mma.sync you must use ptx by asm. Using TensorCores by mma.syncThe following is a simple example that using mma.sync. The layout of A,B,C and D for mma.m8n8k4 is shown in PTX ISA.The mannual of inline PTX assembly is shown in here 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * @author gtyinstinct * GEMM by TensorCores with mma.sync * D = A*B + C*/#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;dim3 grid(1);dim3 block(32);const int M = 8;const int N = 8;const int K = 4;using A_TYPE = double;using B_TYPE = double;using C_TYPE = double;using D_TYPE = double;template&lt;typename A_TYPE, typename B_TYPE, typename C_TYPE, typename D_TYPE, int M, int N, int K &gt;__global__ void mma_test(A_TYPE *A,B_TYPE *B,C_TYPE *C,D_TYPE *D){ asm volatile(&quot;mma.sync.aligned.m8n8k4.row.col.f64.f64.f64.f64 {%0,%1}, {%2}, {%3}, {%4,%5};\\n&quot; : &quot;=d&quot;(D[threadIdx.x*2]), &quot;=d&quot;(D[threadIdx.x*2+1]) : &quot;d&quot;(A[threadIdx.x]), &quot;d&quot;(B[threadIdx.x%4*8+threadIdx.x/4]), &quot;d&quot;(C[threadIdx.x*2]), &quot;d&quot;(C[threadIdx.x*2+1]));} template&lt;typename A_TYPE, typename B_TYPE, typename C_TYPE, typename D_TYPE, int M, int N, int K &gt;__global__ void reference(A_TYPE *A,B_TYPE *B,C_TYPE *C,D_TYPE *D){ for(int idx=threadIdx.x;idx&lt;M*N;idx+=blockDim.x){ int row = idx / N; int col = idx % N; D_TYPE acc = 0; for(int i=0;i&lt;K;i++){ acc += A[row*K+i] * B[i*N+col]; } D[idx] = C[idx] + acc; }}template&lt;typename T&gt;void print(std::string des,T *arr,int row,int col){ std::cout &lt;&lt; &quot;-----&quot; &lt;&lt; des &lt;&lt; &quot;-----&quot; &lt;&lt; '\\n'; for(int i=0;i&lt;row;i++){ for(int j=0;j&lt;col;j++){ std::cout &lt;&lt; std::setw(4) &lt;&lt; arr[i*col+j] &lt;&lt; ' '; } std::cout &lt;&lt; '\\n'; }}template&lt;typename T&gt;void fill_matrix(T *arr,int size){ for(int i=0;i&lt;size;i++){ arr[i] = rand()%64; }}template&lt;typename T&gt;bool validate(T *arr,T *arr_ref,int size){ for(int i=0;i&lt;size;i++){ if(arr[i] != arr_ref[i]){ std::printf(&quot;at %d expected %f but got %f\\n&quot;,i,arr_ref[i],arr[i]); return 0; } } return 1;}int main(){ srand(time(NULL)); A_TYPE *A; B_TYPE *B; C_TYPE *C; D_TYPE *D,*D_ref; cudaMallocManaged(&amp;A,M*K*sizeof(A_TYPE)); cudaMallocManaged(&amp;B,K*N*sizeof(B_TYPE)); cudaMallocManaged(&amp;C,M*N*sizeof(C_TYPE)); cudaMallocManaged(&amp;D,M*N*sizeof(D_TYPE)); cudaMallocManaged(&amp;D_ref,M*N*sizeof(D_TYPE)); fill_matrix&lt;A_TYPE&gt;(A,M*K); fill_matrix&lt;B_TYPE&gt;(B,K*N); fill_matrix&lt;C_TYPE&gt;(C,M*N); print(&quot;A&quot;,A,M,K); print(&quot;B&quot;,B,K,N); print(&quot;C&quot;,C,M,N); mma_test&lt;A_TYPE,B_TYPE,C_TYPE,D_TYPE,M,N,K&gt;&lt;&lt;&lt;grid,block&gt;&gt;&gt;(A,B,C,D); reference&lt;A_TYPE,B_TYPE,C_TYPE,D_TYPE,M,N,K&gt;&lt;&lt;&lt;grid,block&gt;&gt;&gt;(A,B,C,D_ref); cudaDeviceSynchronize(); print(&quot;D&quot;,D,M,N); print(&quot;D_ref&quot;,D_ref,M,N); if(validate(D,D_ref,M*N)){ std::printf(&quot;PASS\\n&quot;); }else{ std::printf(&quot;FAIL\\n&quot;); }} mma.sync in CUTLASSDifferent shape/layout/arch mma.sync used in cutlass is listed at “cutlass/arch/mma*.h”. You can reference that to customize your GEMM. wmma API in CUTLASSDifferent shape/layout/arch wmma API used in cutlass is listed at “cutlass/arch/wmma*.h”.","link":"/2023/04/02/learn-cutlass-3/"},{"title":"冰雹","text":"中午在微博上看到广州下冰雹了，但是自己却没有遇见，今天下午刚到超算，听见外面有几声巨大的雷响，就发现外面在下冰雹，于是想出去感受下被冰雹砸中的感觉，刚到楼下就转为雨点了，这冰雹持续时间也太短了吧。记得上一次遇见冰雹还是在高中时候快高考在教室中模考，当时还特意去窗户边看了下。","link":"/2023/03/24/%E5%86%B0%E9%9B%B9/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"一生一芯","slug":"一生一芯","link":"/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"cutlass","slug":"cutlass","link":"/tags/cutlass/"},{"name":"冰雹","slug":"冰雹","link":"/tags/%E5%86%B0%E9%9B%B9/"}],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"essay","slug":"essay","link":"/categories/essay/"},{"name":"log","slug":"log","link":"/categories/log/"}],"pages":[{"title":"Tianyu Guo (郭天宇)","text":"E-mail : guoty9[at]mail2.sysu.edu.cn My Resume Education Experience year university degree 2018 - 2022 Xidian University B.S. 2022 - now Sun Yat-Sen University Master Experience Teaching Assistant of “SYSU-DCS3013 : Computer Architecture” [2022f] release SYSU-ARCH LAB Research Bachelor’s dissertation “General Computing optimization for GPU based on Cache management” AI final Homework “A Convolutional Neural Network Framework support on CPU and GPU” Weekly Paper Sharing HPCA23","link":"/info/index.html"}]}